from flask import (Blueprint, render_template,
				   jsonify, request)

errors = Blueprint('errors', __name__)

''' 
The handling of status codes 404 and 500 presents a small complication,
in that these errors are normally generated by Flask on its own, and
will return an HTML response. This can confuse an API client,
which will likely expect all responses in JSON format.

That's why here we specifically tweak 404 & 500 errors and don't touch 
them in api/errors (except for 403)

=> One way to generate appropriate responses for all clients is to
make the error han‚Äê dlers adapt their responses based on the format
requested by the client, a technique called content negotiation.

In below written handlers I modified them in such a way that either 
in html or json the response will be given
'''


@errors.app_errorhandler(404)
def error_404(error):
	if request.accept_mimetypes.accept_json and\
	not request.accept_mimetypes.accept_html:
		response = jsonify({'error': 'page not found'})
		response.status_code = 404
		return response
	return render_template('errors/404.html'), 404
	# status code by default is 200, but if we need
	# another one then we should provide it after ','

@errors.app_errorhandler(403)
def error_403(error):
	if request.accept_mimetypes.accept_json and\
	not request.accept_mimetypes.accept_html:
		response = jsonify({'error': 'not enough rights'})
		response.status = 403
		return response
	return render_template('errors/403.html'), 403

@errors.app_errorhandler(500)
def error_500(error):
	if request.accept_mimetypes.accept_json and\
	not request.accept_mimetypes.accept_html:
		response = jsonify({'errors': 'our issues'})
		response.status_code = 500
		return response
	return render_template('errors/500.html')

# errorhandler will be active for only this
# Blueprint. But we want errorhandler to work
# accross entire application hence app_errorhandler